using System;
using System.Collections.Generic;
using UnityEngine;
using UnityEngine.UI;
using Viguar.WeatherDynamics;

#if UNITY_EDITOR
using UnityEditor;
using System.Net;
#endif

namespace Viguar.Aircraft
{
    [RequireComponent(typeof(Rigidbody))]
    public class aircraftController : MonoBehaviour
    {
        //-------------------------------------------------------------------------------------------------------//
        //  CONFIGURABLE VARIABLES BEFORE START                                                                  //
        //-------------------------------------------------------------------------------------------------------//
        #region [Inspector] Aircraft Configuration
        //Aircreaft Config
        public bool m_hasEngines = false;
        public bool m_haslandingGearRetractable = false;
        public bool m_hasAutoStability = false;
        public bool m_usesfuel = false;
        public bool m_hasFlaps = false;
        public Transform customCoM;
        public float takeOffForce = 0f;

        #endregion
        #region [Inspector] Aircraft Handling
        //Aerodynamics 
        public int m_maxServiceCeiling = 50000;
        public float m_Lift = 0.002f;                                   //The amount of lift generated by the aeroplane moving forwards.
        public float m_ZeroLiftSpeed = 300;                             //The speed at which lift is no longer applied - if faster = no more lift.
        public float m_AerodynamicEffect = 0.02f;                       //How much aerodynamics affect the speed of the aeroplane.
        public float m_DragIncreaseFactor = 0.001f;                     //How much drag should increase with speed.
        public float m_stallMargin = 0.16f;                             //AT which rate the aircraft is considered to be stalled (max 0f-1f);
        private float m_AeroFactor;                                     //Used later to turn the airplane towards the direction it is falling
        private float m_BankedTurnAmount;

        //Aircraft Controls Handling       
        //Steering Flight Controls
        public float m_RollEffect = 1f;                                 //The strength of effect for roll input.
        public float m_PitchEffect = 1f;                                //The strength of effect for pitch input.
        public float m_YawEffect = 0.2f;                                //The strength of effect for yaw input.
        public float m_BankedTurnEffect = 0.5f;                         //The amount of turn from doing a banked turn.
        public float m_ThrottleChangeSpeed = 0.3f;                      //The speed with which the throttle changes.

        //Flaps Flight Controls
        public int m_flapStepDegrees;                                   //The flap step turn angle in degrees.
        public int m_maxFlapDegrees;                                    //The maximum amount of flap.
        public float m_flapEffect;                                      //The multiplier of flap strength
        public AnimationCurve m_flapEfficiency = AnimationCurve.Linear(0f, 1f, 1f, 0f); //The additional lift generated by the flaps over speed. 
        public AnimationCurve m_flapDragEfficiency = AnimationCurve.Linear(0f, 0f, 1f, 1f); //The additional lift generated by the flaps over speed. 

        //Breaks & Gears
        public float m_WheelBrakesEffect = 3f;                          //The strength of the brakes when the plane has landed.
        public int m_MaxSteeringWheelAngle;
        public GameObject SteeringWheelContainer;                       //The Parent that contains the nose gear steering wheel colliders.
        public float m_AirBrakesEffect = 3f;                            //How much the air brakes effect the drag.
        public float m_LandingGearDrag = 1.0f;                          //How much drag the landing gear produces.

        //Engine        
        public float m_MaxEnginePower = 40f;                            //The maximum output of the engine.
        public AnimationCurve m_spoolRate = AnimationCurve.Linear(0f, 0f, 1f, 1f);    //Time it takes the engines to spool up.     
        public bool m_EngineOn = false;
        public int m_TogaModePowerOverride = 10;
        private float m_EngineSpool;
        private float m_RequestedEnginePower;
        public bool m_togaOn = false;

        //Fuel
        public float m_fuelTankSize = 100;                              //The amount of fuel that the aircraft carries        
        public AnimationCurve m_fuelconsumption = AnimationCurve.Linear(0f, 0f, 1f, 1f); //The fuel consumpter over engine thrust               
        public float m_currentFuel;                                     //The current fuel amount
        private float m_normalizedFuel;
        private bool m_tankIsEmpty = false;

        //Automatics & Stabilising       
        public float m_AutoTurnPitch = 0.5f;                            //How much the aeroplane automatically pitches when in a banked turn.
        public float m_AutoRollLevel = 0.2f;                            //How much the aeroplane tries to level when not rolling.
        public float m_AutoPitchLevel = 0.2f;                           //How much the aeroplane tries to level when not pitching.  
        public float m_AutoRudder = 0.1f;                               //How much rudder the aeroplane automatically uses when...?

        //StateConditions
        public float m_MaxSafeLandingSpeed = 1f;
        public float m_MaxSafeLandingVerticalSpeed = 1f;
        public float m_LandingAltitudeMargin = 7f;
        public WheelCollider[] m_wheels;
        public float m_MinTakeoffSpeed = 20f;
        #endregion
        #region [Inspector] Aircraft Start Settings
        //Custom settings for start
        public bool m_useAircraftStartSettings = false;
        public bool m_startInMidAir = false;
        public Vector3 m_startVelocity;
        public bool m_startAtCustomPosition = false;
        public Transform m_startPosition;
        public bool m_startWithCustomFuelAmount = false;     //Where or not the aircraft starts with a specific amount of fuel in its tanks
        public float m_FuelStartAmount = 10;                 //The amount of fuel the aircraft starts with
        public bool m_landingGearAtStart = false;
        #endregion
        #region [Inspector] Environment Factors
        public bool m_aircraftAffectedByEnvironment = false;
        public bool m_aircraftAffectedByAthmosphere = false;
        public bool m_aircraftAffectedByWind = false;
        public bool m_aircraftAffectedByPrecipitation = false;

        public AnimationCurve m_thrustTemperatureRatio = AnimationCurve.Linear(0f, 1f, 1f, 0f);
        public AnimationCurve m_thrustDensityRatio = AnimationCurve.Linear(0f, 1f, 1f, 0f);
        #endregion

        //-------------------------------------------------------------------------------------------------------//
        //  AIRCRAFT AND EVNIRONMENT STATUS VARIABLES ARE STORED HERE                                            //
        //-------------------------------------------------------------------------------------------------------//
        #region Aircraft States
        public bool AircraftStateFlying { get; private set; }           //Whether or not the aircraft is considered flying.
        public bool AircraftStateStalled { get; private set; }          //Whether or not the aircraft is considered stalled.
        public bool AircraftStateLanding { get; private set; }          //Whether or not the aircraft is considered landing.
        public bool AircraftStateGrounded { get; private set; }         //Whether or not the aircraft is considered grounded.
        public bool AircraftStateStationary { get; private set; }       //Whether or not the aircraft is considered stationary.
        public bool AircraftStateParked { get; private set; }           //Whether or not the aircraft is considered parked.
        public bool AircraftStateTakingOff { get; private set; }        //Whether or not the aircraft is considered taking off.
        public bool AircraftStateCrashed { get; private set; }          //Whether or not the aircraft is considered crashed.        
        private bool m_Immobilized = false;                             //Used for making the plane uncontrollable, i.e. if it has been hit or crashed.
        #endregion
        #region Aircraft Status
        //Aircraft 
        public float LiftPower { get; private set; }                    //The strength of lift.
        public Vector3 LiftDirection { get; private set; }              //The direction of lift of the aircrafts wings.
        public Vector3 Forces { get; private set; }                     //The forces exerted onto the aircraft.
        public float Drag { get; private set; }                         //The current drag of the aircraft.
        public float AngularDrag { get; private set; }                  //The current angular drag of the aircraft.
        public float DragEfficiency { get; private set; }               //How effective the drag is at altitude.

        public float Heading { get; private set; }                      //The aircrafts compass heading with +Z as northern direction.
        public float Altitude { get; private set; }                     //The aircrafts height above the ground.
        public float ForwardSpeed { get; private set; }                 //The aircrafts speed in forward facing direction.
        public float VerticalSpeed { get; private set; }                //The aircrafts climb/descent speed.                  
        public float RollAngle { get; private set; }                    //The angle of roll of the aircraft
        public float PitchAngle { get; private set; }                   //The angle of pitch of the aircraft.

        //Control Inputs
        public float ControlSurfaceEfficiency { get; private set; }     //The efficieny of controls at altitude.
        public float ThrottleInput { get; private set; }                //The input value of the throttle key.        
        public float RollInput { get; private set; }                    //The amount of input on the roll axis.
        public float PitchInput { get; private set; }                   //The amount of input on the pitch axis.
        public float YawInput { get; private set; }                     //The amount of input on the yaw axis.

        public bool AirBrakes { get; private set; }                     //Whether or not the air brakes are being applied.        
        public bool FlapsInput { get; private set; }                    //Whether or not to increase flaps.
        public bool LandingGearInput { get; private set; }              //Whether or not the landing gear is called.
        public bool TogaInput { get; private set; }                     //Wherther or not TogaMode is being called.


        public bool ActiveAutomatics { get; private set; }             //Whether of not the aircraft automatically stabilises.

        //Flaps
        public int Flaps { get; private set; }                          //Whether or not the flap are being altered.
        public float FlapLift { get; private set; }                     //The amount of lift that the flaps add.
        public float FlapDrag { get; private set; }                     //The amount of drag the the flaps add.

        //Engines     
        public float Throttle { get; private set; }                     //The amount of throttle being used.
        public float EnginePower { get; private set; }                  //How much power the engine is being given.
        public float EngineEfficiency { get; private set; }             //The factor of engine power.
        public float MaxEnginePower { get { return m_MaxEnginePower; } }//The maximum output of the engine. 
        public bool EngineOn { get; private set; }                      //The onOff status of the engine.        
        public bool TogaMode { get; private set; }                      //Bool to (de-)activate toga mode. (Take-Off/Go-Around)
        public float TogaPowerOutput { get; private set; }

        //Fuel
        public float FuelAmount { get; private set; }
        public float FuelConsuption { get; private set; }

        //Gear
        public bool GearExtended { get; private set; }                  //Whether or not the landing gear is down.    
        public int WheelsAmount { get; private set; }                   //The amount of wheels on the aircraft.

        //Landing
        public bool InLandingSpeedRegime { get; private set; }          //Whether or not the aircraft is within the safe landing speed range.
        public bool InLandingVerticalSpeedRegime { get; private set; }  //Whether or not the aircraft is withing the safe vertical landing speed range.    

        #endregion
        #region Autoflight System
        #region A/P
        public bool ApOverrideInput { get; private set; }               //Returns true when appropriate input overrides the auto pilot.
        public bool ApOverrideInputPitch { get; private set; }          //Returns true when pitch input overrides the auto pilot.
        public bool ApOverrideInputYawRoll { get; private set; }        //Returns true when yaw or roll input overrides the auto pilot.
        public bool ApToggleInput { get; private set; }                 //Returns true when the autopilot has been activated.
        public bool ApOnline { get; private set; }                      //Whether or not the auto pilot is able to take command. 
        public bool ApInCommand { get; private set; }                   //Whether or not the auto pilot is activated.

        public bool ApModeHeading { get; private set; }                 //The auto pilot mode for turning towards a selected heading.
        public bool ApModeAltitude { get; private set; }                //The auto pilot mode for climbing/descending to a selected altitude.

        public float ApHeadingTarget { get; private set; }              //The target heading that the auto pilot will aim to turn to.
        public float ApAltitudeTarget { get; private set; }             //The target altitude that the auto pilot will aim to climb to and maintain.
        public float ApVsTarget { get; private set; }                   //The vertical speed at which the auto pilot will climb to the target altitude.
        public float ApMaxVerticalRate { get; private set; }            //The maximum vertical speed that the auto pilot is allowed to climb and descend with.
        public float ApMaxRollAngle { get; private set; }               //The maximum roll angle that the auto pilot is allowed to turn the aircraft at.

        private float ApHeadingAltitude;
        private float ApHeadingDir;
        private float ApPitchDir;
        #endregion
        #region A/T
        public bool AtToggleInput { get; private set; }                 //Returns true when the autothrottle has been activated.
        public bool AtModeInput { get; private set; }                   //Returns true when the autothrottle mode has been switched.
        public bool AtOverrideInput { get; private set; }               //Returns true when appropriate input overrides the auto throttle.
        public bool AtOnline { get; private set; }                      //Whether or not the auto throttle is able to take command.
        public bool AtInCommand { get; private set; }                   //Whether or not the auto throttle system is activated.

        public bool AtModeMaintain { get; private set; }                //The auto throttle mode for maintaining a speed.
        public bool AtModeThrust { get; private set; }                  //The auto throttle mode for maintaining a climb rate.
        public float AtTarget { get; private set; }                     //The target speed/rate for the auto throttle to aim for.

        //Private Storages
        private Vector3 targetVelocity;
        private Vector3 targetForce;
        private float targetThrottlePosition;
        private bool targetChanged;
        #endregion


                 
        #endregion
        #region Aircraft Environment Status      
        #region Weather Imact On Aircraft
        public bool AffectedByWeather { get; private set; }         //Whether or not weather impacts the flight of the aircraft.
        public bool AffectedByAtmosphere { get; private set; }      //Whether or not atmospheric settings impact the flight of the aircraft.
        public bool AffectedByWind { get; private set; }            //Whether of not wind settings impact the flight of the aircraft.
        public bool AffectedByPrecipitation { get; private set; }   //Whether or not precipitation levels impact the flight of the aircraft.
        #endregion
        #region Environment Properties At Sea Level
        public float CurrentSeaLevelTemperature { get; private set; } //The temperature at sea level of the weather zone the aircraft is currently in.
        public float CurrentSeaLevelAirpressure { get; private set; } //The air pressure at sea level of the weather zone the aircraft is currently in.
        public float CurrentSeaLevelHumidity { get; private set; }    //The humidty at sea level of the weather zone the aircraft is currently in.
        public float CurrentSeaLevelAirDensity { get; private set; }  //The calculated density of air depending on the three values above.
        #endregion
        #region Envionment Properties At Altitude
        public float TemperatureFalloffRate { get; private set; }   //How many degrees the temperature drops every 100 meters of altitude.
        public float HumidityFalloffRate { get; private set; }      //How many % the relative humidity drops every 100 meters of altitude.

        public float AltitudeTemperature { get; private set; }      //The temperature at the current altitude of the aircraft.
        public float AltitudeAirpressure { get; private set; }      //The atmospheric pressure at the current altitude of the aircraft.
        public float AltitudeHumidity { get; private set; }         //The relative humidity at the current altitude of the aircraft.
        public float AltitudeAirdensity { get; private set; }       //The calculated air density at the current altitude of the aircraft.
        #endregion
        #region Wind Properties At Altitude
        public float AltitudeWindFactor { get; private set; }       //The intensity of wind at the current altitude of the aircraft.
        public float WindStrength { get; private set; }             //The strength multiplier for wind.
        public float ZoneWindStrength { get; private set; }         //The live wind strength of the current zone.
        #endregion       
        #endregion
        #region Other Values
        private float m_OriginalDrag;         // The drag when the scene starts.
        private float m_OriginalAngularDrag;  // The angular drag when the scene starts.

        private Transform m_originalPosition;
        private Transform m_originalRotation;

        private float m_originalLandingGearDrag;
        private float m_originalMaxPower;

        private Rigidbody m_Rigidbody;
        private weatherWindZone m_windZone;
        #endregion
        //-------------------------------------------------------------------------------------------------------//
        //                                                                                                       //
        //-------------------------------------------------------------------------------------------------------//
        //  FUNCTIONS                                                                                            //
        //-------------------------------------------------------------------------------------------------------//

        private void Start()
        {
            getAircraftComponents();
            setUpAircraft();
            initStartingValues();
            initAT();
            initAP();                          
            controlWeatherImpactTypes();
        }

        public void Move(float rollInput, float pitchInput, float yawInput, float throttleInput)
        {        
            if (!ApModeAltitude) { PitchInput = pitchInput; }
            if (!ApModeHeading) { YawInput = yawInput; }
            if (!ApModeHeading) { RollInput = rollInput; }         
            if (!AtInCommand) { ThrottleInput = throttleInput; }

            controlAircraftWeatherModifiers();
            HandleMainFlightFunctions();
            updateFlightState();
        }
        public void ControlFlightSystems(bool airBrakesInput, bool flapsInput, bool gearInput, bool toga)
        {
            #region inputProperties
            AirBrakes = airBrakesInput;
            FlapsInput = flapsInput;
            LandingGearInput = gearInput;
            TogaInput = toga;
            #endregion
            HandleAircraftSystems();
        }
        public void UpdateWeatherZoneValues(float seaTemp, float seaPress, float seaHum, weatherWindZone wind, float tempFalloff, float humFalloff)
        {
            CurrentSeaLevelTemperature = seaTemp;
            CurrentSeaLevelAirpressure = seaPress;
            CurrentSeaLevelHumidity = seaHum;
            m_windZone = wind;
            TemperatureFalloffRate = tempFalloff;
            HumidityFalloffRate = humFalloff;
            calculateSeaLevelDensity();
        }

        public void ControlFlightAutomaticsAT(bool atToggle, bool atMode, bool atOverride)
        {
            AtToggleInput = atToggle;
            AtModeInput = atMode;
            AtOverrideInput = atOverride;

            runAT();           
        }
        public void ControlFlightAutomaticsAP(bool apToggle, bool apOverridePitch, bool apOverrideYawRoll)
        {
            ApToggleInput = apToggle;
            ApOverrideInputPitch = apOverridePitch;
            ApOverrideInputYawRoll = apOverrideYawRoll;          
            if (ApOverrideInputPitch || ApOverrideInputYawRoll) { ApOverrideInput = true; } else { ApOverrideInput = false; }

            runAP();
        }
        //-------------------------------------------------------------------------------------------------------//
        //  MAIN FLIGHT FUNCTIONS                                                                                //
        //-------------------------------------------------------------------------------------------------------//
        #region [MAIN FLIGHT] Function Management
        private void HandleMainFlightFunctions()
        {
            CalculateMainFlightPhysics();
            ClampInputs();
            AutoLevel();
        }
        private void CalculateMainFlightPhysics()
        {
            CalculateForwardSpeed();
            CalculateVerticalSpeed();
            CalculateRollAndPitchAngles();
            CalculateAltitude();
            CalculateCurrentCompassHeading();

            CaluclateAerodynamicEffect();
            CalculateDrag();
            CalculateLinearForces();
            CalculateTorque();

        }
        private void HandleAircraftSystems()
        {
            ControlEngines();
            ControlLandingGearBrakes();
            DriveWheelsWhenGrounded();
            ControlFlaps();
            ControlToga(TogaInput);
        }
        #endregion
        #region [MAIN FLIGHT] Value Handling
        private void ClampInputs() //Clamp the inputs to -1 to 1 range
        {
            RollInput = Mathf.Clamp(RollInput, -1, 1);
            PitchInput = Mathf.Clamp(PitchInput, -1, 1);
            YawInput = Mathf.Clamp(YawInput, -1, 1);
            ThrottleInput = Mathf.Clamp(ThrottleInput, -1, 1);
        }

        #endregion
        #region [MAIN FLIGHT] Aerodynamics & Physics

        private void CaluclateAerodynamicEffect() //"Aerodynamic" calculations. This is a very simple approximation of the effect that a plane will naturally try to align itself in the direction that it's facing when moving at speed.
        { //Without this, the plane would behave a bit like the asteroids spaceship!

            if (m_Rigidbody.velocity.magnitude > 0)
            {
                m_AeroFactor = Vector3.Dot(transform.forward, m_Rigidbody.velocity.normalized); // compare the direction we're pointing with the direction we're moving:                             
                m_AeroFactor *= m_AeroFactor; //Multipled by itself results in a desirable rolloff curve of the effect                                 
                var newVelocity = Vector3.Lerp(m_Rigidbody.velocity, transform.forward * ForwardSpeed, m_AeroFactor * ForwardSpeed * m_AerodynamicEffect * Time.fixedDeltaTime); //Calculate a new velocity by bending current velocity direction towards direction of plane facing, by amount based on aeroFactor
                m_Rigidbody.velocity = newVelocity;
                if (!AircraftStateGrounded) //This condition prevents the aircraft to spazz arond like some retard when stationary.
                {
                    m_Rigidbody.rotation = Quaternion.Slerp(m_Rigidbody.rotation, Quaternion.LookRotation(m_Rigidbody.velocity, transform.up), m_AerodynamicEffect * Time.fixedDeltaTime * Mathf.InverseLerp(m_ZeroLiftSpeed, 0, ForwardSpeed)); //Also rotate the plane towards the direction of movement - this should be a very small effect, but means the plane ends up pointing downwards in a stall                    
                }
            }
        }
        private void CalculateDrag()
        {
            CalculateLandingGearDrag(m_haslandingGearRetractable);
            float extraDrag = m_Rigidbody.velocity.magnitude * m_DragIncreaseFactor; //Increase the drag based on speed, since a constant drag doesn't seem "Real" (tm) enough      
            Drag = (AirBrakes ? (m_OriginalDrag + extraDrag) * FlapDrag * m_AirBrakesEffect * DragEfficiency : (m_OriginalDrag + extraDrag) * FlapDrag * DragEfficiency); //Air brakes work by directly modifying drag. This part is actually pretty realistic! 
            AngularDrag = m_OriginalAngularDrag * ForwardSpeed * DragEfficiency; //Forward speed affects angular drag - at high forward speed, it's much harder for the plane to spin.
            m_Rigidbody.drag = Drag;
            m_Rigidbody.angularDrag = AngularDrag;
        }
        private void CalculateLinearForces() //Calculate forces acting on the aeroplane:
        {            
            var forces = Vector3.zero; //Accumulate forces into variable            
            forces += EnginePower * transform.forward; //Add the engine power in the forward direction   
            if (AffectedByAtmosphere) { forces *= EngineEfficiency; }
            var liftDirection = Vector3.Cross(transform.forward * ForwardSpeed, transform.right).normalized; //The direction that the lift force is applied is at right angles to the plane's velocity (usually, this is 'up'!)           
            var zeroLiftFactor = Mathf.InverseLerp(m_ZeroLiftSpeed, 0, ForwardSpeed); //The amount of lift drops off as the plane increases speed - in reality this occurs as the pilot retracts the flaps. giving the plane less drag, but less lift. Because we don't simulate flaps, this is automatically           
            var liftPower = ForwardSpeed * ForwardSpeed * m_Lift * zeroLiftFactor * m_AeroFactor; //Calculate and add the lift power                     
            var rollLiftFactor = Mathf.InverseLerp(2, 0.5f, Math.Abs(RollAngle));
            liftDirection.y *= rollLiftFactor;
            forces += (liftPower + FlapLift) * liftDirection;
            if (AffectedByWind) { forces += m_windZone.transform.forward * m_windZone.z_CurrentWindStrength * WindStrength; ZoneWindStrength = m_windZone.z_CurrentWindStrength; }
            LiftPower = liftPower + FlapLift;
            LiftDirection = liftDirection;
            Forces = forces;
            m_Rigidbody.AddForce(forces); //Apply the calculated forces to the the Rigidbody    
        }
        private void CalculateTorque()
        {
            if (!m_Immobilized)
            {
                var rollTurn = (RollAngle == 0 || Mathf.Abs(RollAngle) > 2 ? 0 : Mathf.InverseLerp(0, 2, Mathf.Abs(RollAngle)));
                var torque = Vector3.zero; //Accumulate torque forces into variable:            
                torque += PitchInput * m_PitchEffect * transform.right; //Add torque for the pitch based on the pitch input.                 
                torque += YawInput * m_YawEffect * transform.up; //Add torque for the yaw based on the yaw input.                   
                torque += -RollInput * m_RollEffect * transform.forward; //Add torque for the roll based on the roll input.                      
                torque += m_BankedTurnAmount * m_BankedTurnEffect * transform.up; //Add torque for banked turning.                             
                if (AffectedByAtmosphere) { torque *= ControlSurfaceEfficiency; }
                torque += (transform.up * RollAngle / rollTurn * m_YawEffect * Mathf.InverseLerp(m_ZeroLiftSpeed, 0, ForwardSpeed)) / 2;
                torque *= ForwardSpeed * m_AeroFactor;                
                m_Rigidbody.AddTorque(torque); //The total torque is multiplied by the forward speed, so the controls have more effect at high speed, and little effect at low speed, or when not moving in the direction of the nose of the plane (i.e. falling while stalled)                
            }
        }

        #endregion
        #region [MAIN FLIGHT] Aircraft Orientation
        private void CalculateRollAndPitchAngles() //Calculate roll & pitch angles 
        {
            var flatForward = transform.forward; //Calculate the flat forward direction (with no y component).
            flatForward.y = 0;

            if (flatForward.sqrMagnitude > 0) //If the flat forward vector is non-zero (which would only happen if the plane was pointing exactly straight upwards)
            {
                flatForward.Normalize();
                var localFlatForward = transform.InverseTransformDirection(flatForward); //Calculate current pitch angle
                PitchAngle = Mathf.Atan2(localFlatForward.y, localFlatForward.z);
                var flatRight = Vector3.Cross(Vector3.up, flatForward); //Calculate current roll angle
                var localFlatRight = transform.InverseTransformDirection(flatRight);
                RollAngle = Mathf.Atan2(localFlatRight.y, localFlatRight.x);
            }
        }
        private void CalculateAltitude() //Altitude calculations - raycast downwards from the aeroplane
        {
            /*
            var ray = new Ray(transform.position - Vector3.up * 3, -Vector3.up); //Safe distance starting below the plane to avoid colliding with any of the plane's own colliders
            Debug.DrawRay(transform.position - Vector3.up * 3, -Vector3.up, Color.red);
            RaycastHit hit;
            Altitude = Physics.Raycast(ray, out hit) ? hit.distance + 3 : transform.position.y;
            */
            Altitude = transform.position.y;
        }
        private void CalculateForwardSpeed() //Forward speed is the speed in the planes's forward direction (not the same as its velocity, eg if falling in a stall)
        {
            var localVelocity = transform.InverseTransformDirection(m_Rigidbody.velocity);
            ForwardSpeed = Mathf.Max(0, localVelocity.z);
        }
        private void CalculateVerticalSpeed()
        {
            VerticalSpeed = m_Rigidbody.velocity.y;
        }
        private void CalculateCurrentCompassHeading()
        {
            float radianHeading = (Mathf.Atan2(m_Rigidbody.velocity.x, m_Rigidbody.velocity.z) * Mathf.Rad2Deg);
            radianHeading = (radianHeading + 360f) % 360f;
            Heading = radianHeading;
        }
        #endregion
        #region [MAIN FLIGHT] Flight Stabilisation
        private void AutoLevel() //The banked turn amount (between -1 and 1) is the sine of the roll angle. This is an amount applied to elevator input if the user is only using the banking controls, because that's what people expect to happen in games! 
        {
            if (ActiveAutomatics)
            {
                m_BankedTurnAmount = Mathf.Sin(RollAngle);
                if (RollInput == 0f) //Auto level roll, if there's no roll input:
                {
                    RollInput = -RollAngle * m_AutoRollLevel;
                }
                if (PitchInput == 0f) //Auto correct pitch, if no pitch input (but also apply the banked turn amount)
                {
                    PitchInput = -PitchAngle * m_AutoPitchLevel;
                    PitchInput -= Mathf.Abs(m_BankedTurnAmount * m_BankedTurnAmount * m_AutoTurnPitch);
                }
            }

        }
        #endregion
        #region [MAIN FLIGHT] Aircraft States
        //-------------------------------------------------------------------------------------------------------//
        // The aircraft can have the following states:
        // Flying/Gliding, Stalling, Landing, Taking Off, Grounded, Stationary, Parked, Crashed 
        // The aircraft can be in more than one state at the same time (e.g. [Flying] & [Stalling], as they do not cancel each other out). Their conditions go as follows.
        // There are two main types - one requiring the aircraft to be [Flying], the other requiring the aircraft to be [Grounded]. However, the state [Crashed] may always occur.
        //
        // [State Flying (& Gliding)]
        //      Condition 1: The aircraft is not in the state [Grounded].
        //      Condition 2: The aircraft is not in the state [Crashed].
        //
        // [State Stalling] (Requires flying)
        //      Condition 1: The difference of the aircrafts' facing-direction and its' moving-direction is greater than the m_stallMargin.
        //      Condition 2: The aircraft is currently in the state [Flying].
        //  
        // [State Landing] (Requires flying)
        //      Condition 1: The aircraft is currently in the state [Flying].
        //      Condition 2: The aircraft is not in the state [Stalling].  
        //      Condition 3: The aircrafts' landing gear is extended.
        //      Condition 4: The aircraft is at low enough altitude.
        //      Condition 5: The aircraft is not faster than its maximum landing speed.
        //      Condition 6: The aircraft is not descending faster than its maximum rate of descent.
        //
        //
        // [State Grounded]
        //      Condition 1: The aircraft's landing gear is extended.
        //      Condition 2: At least 50% of the aircraft's wheels are touching the ground.
        //      Condition 3: The aircraft is slower than the maximum ground speed/minimum takeoff speed.
        //      Condition 4: The aircraft is not in the state [Crashed].
        //
        // [State Stationary] (Requires grounded)
        //      Condition 1: The aircraft is currently in the state [Grounded].      
        //      Condition 2: The aircrafts' speed is slower than 1.
        //      Condition 3: The aircrafts' engines are switched ON, if it has any.
        //      Condition 4: The aircrafts' throttle is set to 0.
        //
        // [State Parked] (Requires grounded)
        //      Condition 1: The aircraft is currently in the state [Stationary].
        //      Condition 2: The aircraft's engines are switched OFF, if it has any.
        //      Condition 3: The aircraft is fully switched off, so to say.
        //
        // [State Taking Off] (Requires grounded)
        //      Condition 1: The aircraft is in the state [Grounded].
        //      Condition 2: The aircraft is not in the state [Stationary] or [Parked].
        //      Condition 3: The aircraft's landing gear is extended.
        //      Condition 4: The aircraft is in TOGA-mode, if it is enabled.
        //      Condition 5: The aircraft is below landing altitude.
        //      Condition 6: The aircraft faster than the maximum ground speed/minimum takeoff speed.
        //
        // [State Crashed]
        //      Condition 1: The aircraft had a collision with another object with a velocity greater than FINDAWAYTODOTHIS.
        //
        //-------------------------------------------------------------------------------------------------------//

        private void updateFlightState()
        {
            checkForStateInFlight();
            checkForStateOnGround();
        }

        #region Determine Aircraft States
        //States that require [Flying]
        private void checkForStateInFlight() //When is the airplane considered to be flying?
        {
            if (!AircraftStateGrounded && !AircraftStateCrashed)
            {
                AircraftStateFlying = true;
                checkForStateInStall();
                checkForStateInLanding();
                checkForStateInTakeoff();
            }
            else
            {
                AircraftStateFlying = false;
            }
        }
        private void checkForStateInStall() //When is the airplane considered to be in a stall?
        {
            //This method only is called when the aircraft state is [Flying], so it's not checked in here.
            if (Vector3.Dot(transform.forward, m_Rigidbody.velocity.normalized) < m_stallMargin && !AircraftStateGrounded)
            {
                AircraftStateStalled = true;
                Immobilize(true);
            }
            else
            {
                if (Vector3.Dot(transform.forward, m_Rigidbody.velocity.normalized) > 1 - Mathf.InverseLerp(0, 2f, PitchAngle)) //If our Facing/Moving ratio is larger than our pitch
                {
                    AircraftStateStalled = false;
                    Immobilize(false);
                }
            }
        }
        private void checkForStateInLanding() //When is the airplane considered to be attempting to land?
        {
            //This method only is called when the aircraft state is [Flying], so it's not checked in here.
            if (GearExtended && !AircraftStateStalled && ForwardSpeed < m_MaxSafeLandingSpeed && VerticalSpeed < m_MaxSafeLandingVerticalSpeed && Altitude < m_LandingAltitudeMargin && AircraftStateFlying)
            {
                AircraftStateLanding = true;
            }
            else
            {
                AircraftStateLanding = false;
            }
        }


        //States that require [Grounded]
        private void checkForStateOnGround() //When is the airplane considered to be on the ground?
        {
            //maybe add that if wheels are in range of floor (+- 1 m or so?)
            if (WheelsAmount > 0)
            {
                int groundedWheels = 0;
                foreach (WheelCollider wheel in m_wheels)
                {
                    if (wheel.isGrounded)
                    {
                        groundedWheels = groundedWheels + 1;
                    }
                }
                if (groundedWheels >= WheelsAmount / 2 && GearExtended)
                {
                    AircraftStateGrounded = true;
                    checkForStateIsStationary();
                    checkForStateIsParked();
                    checkForStateInTakeoff();
                    checkForStateInLanding();
                    checkForStateInStall();
                }
                else
                {
                    AircraftStateGrounded = false;
                    groundedWheels = 0;
                }
            }



            //disable all sorts of flight things?
            //allow wheel brake?
        }
        private void checkForStateIsStationary() //When is the airplane considered to be stationary on the ground?
        {
            //This method only is called when the aircraft state is [Grounded], so it's not checked in here.
            //The method [Grounded] only is called when the aircraft has it's [GearExtended], so it's not checked in here.
            if (AircraftStateGrounded && ForwardSpeed < 1f && Throttle == 0)
            {
                AircraftStateStationary = true;
                AircraftStateTakingOff = false;
            }
            else
            {
                AircraftStateStationary = false;
            }
        }
        private void checkForStateIsParked() //When is the airplane considered to be parked?
        {
            //This method only is called when the aircraft state is [Grounded], so it's not checked in here.
            //The method [Grounded] only is called when the aircraft has it's [GearExtended], so it's not checked in here.
            if (AircraftStateStationary && !EngineOn)
            {
                AircraftStateParked = true;
                AircraftStateTakingOff = false;
            }
            else
            {
                AircraftStateParked = false;
            }
        }
        private void checkForStateInTakeoff() //When is the airplane considered to be attempting to take off?
        {
            //This method only is called when the aircraft state is [Grounded], so it's not checked in here.
            //The method [Grounded] only is called when the aircraft has it's [GearExtended], so it's not checked in here.
            if (!AircraftStateParked && !AircraftStateStationary && ForwardSpeed > m_MinTakeoffSpeed && Altitude < m_LandingAltitudeMargin && !AircraftStateFlying && !AirBrakes) //add toga at some point
            {
                AircraftStateTakingOff = true;
                var torque = Vector3.zero;
                torque += PitchInput * m_PitchEffect * transform.right;
                m_Rigidbody.AddTorque(torque * ForwardSpeed * takeOffForce);
            }
            else
            {
                AircraftStateTakingOff = false;
            }


        }


        //States that can occur without requirements
        private void checkForStateCrashed() //When has the airplane crashed?
        {
            //AircraftStateCrashed = true;
        }

        #endregion

        #endregion
        //-------------------------------------------------------------------------------------------------------//
        //  AIRCRAFT SYSTEMS FUNCTIONS                                                                           //
        //-------------------------------------------------------------------------------------------------------//       
        #region [AIRCRAFT SYSTEMS] Engines  
        public void toggleEngineState()
        {
            EngineOn = !EngineOn;
        }
        public void setEngineState(bool engineState)
        {
            EngineOn = engineState;
        }
        private void ControlEngines()
        {
            if (m_hasEngines)
            {
                ControlThrottle();
                if (EngineOn)
                {
                    SpoolUpEngines();
                    controlFuel();
                    //controlToga();
                }
                else
                {
                    EnginePower = 0;
                }
            }
            else
            {
                setEngineState(false);
            }
        }
        private void ControlThrottle()
        {
            Throttle = Mathf.Clamp01(Throttle + ThrottleInput * Time.fixedDeltaTime * m_ThrottleChangeSpeed); //Adjust throttle based on throttle input (or immobilized state)            
            m_RequestedEnginePower = Throttle * m_MaxEnginePower;
        }
        private void SpoolUpEngines()
        {
            if (EnginePower < m_RequestedEnginePower)
            {
                float spoolrate = m_spoolRate.Evaluate(Throttle);
                m_EngineSpool = spoolrate * 100;
                EnginePower = EnginePower + m_EngineSpool * m_ThrottleChangeSpeed;
            }
            if (EnginePower > m_RequestedEnginePower)
            {
                //EnginePower = m_RequestedEnginePower;
                float spoolrate = m_spoolRate.Evaluate(1 - Throttle);
                m_EngineSpool = spoolrate * 100;
                EnginePower = EnginePower - m_EngineSpool * m_ThrottleChangeSpeed;
            }
        }
        #endregion
        #region [AIRCRAFT SYSTEMS] ToGa Mode
        private void ControlToga(bool toga)
        {
            if (toga)
            {
                toggleTogaMode();
            }
            onToga();
        }
        private void onToga()
        {
            if (TogaMode)
            {
                m_MaxEnginePower = TogaPowerOutput;
            }
            else
            {
                m_MaxEnginePower = m_originalMaxPower;
            }
        }
        public void toggleTogaMode()
        {
            TogaMode = !TogaMode;
        }
        public void setTogaMode(bool togaTrue)
        {
            TogaMode = togaTrue;
        }
        #endregion        
        #region [AIRCRAFT SYSTEMS] Fuel System
        #region Base Fuel
        private void controlFuel()
        {
            if (m_usesfuel && EngineOn)
            {
                if (!m_tankIsEmpty)
                {
                    burnFuel();
                }
                if (m_tankIsEmpty)
                {
                    setEngineState(false);
                }
            }
        }

        private void burnFuel()
        {
            if (Throttle < 0.01f)
            {
                burnFuelAtIdle();
            }
            else
            {
                burnFuelAtThrottle();
            }
        }

        private void burnFuelAtIdle()
        {
            float ConsumptionRate = m_fuelconsumption.Evaluate(0.01f);
            ConsumptionRate = ConsumptionRate * Time.fixedDeltaTime;
            reduceFuel(ConsumptionRate);
        }

        private void burnFuelAtThrottle()
        {
            float ConsumptionRate = m_fuelconsumption.Evaluate(Throttle);
            ConsumptionRate = ConsumptionRate * Time.fixedDeltaTime;
            reduceFuel(ConsumptionRate);
        }

        private void checkfuelTank()
        {
            //Check Brimming
            if (m_currentFuel > m_fuelTankSize)
            {
                m_currentFuel = m_fuelTankSize;
            }
            //Check Empty
            if (m_currentFuel < 0)
            {
                m_tankIsEmpty = true;
                m_currentFuel = 0;
            }
            else
            {
                m_tankIsEmpty = false;
            }
        }

        //public vars
        public void initFuel()
        {
            m_currentFuel = 0;
        }

        public void addFuel(float addAmount)
        {
            m_currentFuel = m_currentFuel + addAmount;
            checkfuelTank();
        }

        public void reduceFuel(float reduceAmount)
        {
            m_currentFuel = m_currentFuel - reduceAmount;
            checkfuelTank();
        }

        #endregion
        #endregion
        #region [AIRCRAFT SYSTEMS] Landing Gear

        private void ControlLandingGearBrakes()
        {
            if (AircraftStateGrounded)
            {
                foreach (WheelCollider wheel in m_wheels)
                {
                    wheel.brakeTorque = (AirBrakes ? wheel.brakeTorque = m_WheelBrakesEffect * 10 : wheel.brakeTorque = 0f);
                }
            }
        }
        private void CountLandingGearWheels()
        {
            m_wheels = GetComponentsInChildren<WheelCollider>();
            WheelsAmount = m_wheels.Length;
        }
        private void DriveWheelsWhenGrounded()
        {
            if (AircraftStateGrounded)
            {
                WheelCollider[] steeringWheels;
                steeringWheels = SteeringWheelContainer.GetComponentsInChildren<WheelCollider>();
                foreach (WheelCollider wheel in m_wheels)
                {
                    wheel.motorTorque = ThrottleInput * 10000;
                }
                foreach (WheelCollider steeringWheel in steeringWheels)
                {
                    steeringWheel.steerAngle = YawInput * m_MaxSteeringWheelAngle;
                }
            }
        }
        private void CalculateLandingGearDrag(bool hasLandingGear)
        {
            if (hasLandingGear && GearExtended)
            {
                m_LandingGearDrag = m_originalLandingGearDrag;
            }
            else
            {
                m_LandingGearDrag = 1;
            }
        }
        public void toggleLandingGear()
        {
            GearExtended = !GearExtended;
        }
        public void setLandingGear(bool lgear)
        {
            GearExtended = lgear;
        }
        #endregion
        #region [AIRCRAFT SYSTEMS] Flaps  
        public void ControlFlaps()
        {
            if (m_hasFlaps)
            {
                setFlapSettings();
                calculateFlapLiftAndDragEffects();
            }
        }

        private void setFlapSettings()
        {
            if (FlapsInput)
            {
                Flaps = Flaps + m_flapStepDegrees;
                if (Flaps > m_maxFlapDegrees)
                {
                    Flaps = 0;
                }
            }
        }

        private void calculateFlapLiftAndDragEffects()
        {

            float currentSpeedPercentage;
            float currentFlapLift;
            float currentFlapDrag;

            currentSpeedPercentage = ForwardSpeed / m_ZeroLiftSpeed;
            if (currentSpeedPercentage > 1)
            {
                currentSpeedPercentage = 1;
            }

            //Flap Efficiency over Speed
            currentFlapLift = m_flapEfficiency.Evaluate(currentSpeedPercentage);
            FlapLift = currentFlapLift * Flaps / m_maxFlapDegrees * m_flapEffect;

            //Flap Drag Increase over Speed     
            currentFlapDrag = m_flapDragEfficiency.Evaluate(currentSpeedPercentage);
            FlapDrag = currentFlapDrag * Flaps / m_maxFlapDegrees + 1;
        }


        #endregion
        #region [AIRCRAFT SYSTEMS] Auto Flight Systems
        #region [Auto Throttle]        
        #region [Auto Throttle] Setup & Detection Functions
        private void initAT()
        {
            AtOnline = true;
            AtInCommand = false;           
            AtModeMaintain = true;
            AtTarget = 0;
        }              
        private void runAT()
        {
            if (AtToggleInput) { ToggleAutoThrottle(); }
            if (AtOverrideInput && AtInCommand) { AtInCommand = false; }
            if(!AtOnline) { AtInCommand = false; }

            if (AtModeInput && AtOnline) { SwitchAutoThrottleMode(); }

            if (AtModeMaintain && AtInCommand) { atMaintainSpeed(); }
            else if (AtModeThrust && AtInCommand) { atSetThrust(); }           
        }
        #endregion
        #region [Auto Throttle] Mode Handling        
        public void ToggleAutoThrottle()
        {
            if (AtOnline)
            {
                if (AtTarget >= 1) { AtInCommand = !AtInCommand; }
            }
            else
            {
                AtOnline = !AtOnline;
            }
        }
        public void SwitchAutoThrottleMode()
        {
            if (AtModeMaintain)
            {
                AtInCommand = false;
                AtModeThrust = true;
                AtModeMaintain = false;
                AtTarget = 0;
            }
            else
            {
                AtInCommand = false;
                AtModeMaintain = true;
                AtModeThrust = false;
                AtTarget = 0;
            }
        }
        public void SetAutoThrottleTarget(float target)
        {
            AtTarget = target;
            targetChanged = true;
        }
        #endregion
        #region [Auto Throttle] Mode Functions
        private void atMaintainSpeed()
        {
            targetVelocity = Vector3.forward * AtTarget;
            targetForce = ((m_Rigidbody.mass * targetVelocity) - (m_Rigidbody.mass * m_Rigidbody.velocity)) / Time.fixedDeltaTime;
            targetForce = targetForce.normalized;
            targetThrottlePosition = targetForce.z;
            if (Throttle < targetThrottlePosition)
            {
                atIncreaseThrottle(0.005f);
                if (Throttle > targetThrottlePosition) { ThrottleInput = 0; }
            }
            if (Throttle > targetThrottlePosition)
            {
                atReduceThrottle(0.005f);
                if (Throttle < targetThrottlePosition) { ThrottleInput = 0; }
            }
        }
        private void atSetThrust()
        {
            AtTarget = Mathf.Clamp(AtTarget, 0, 100);
            if (targetChanged && Throttle <= (AtTarget / 100))
            {
                atIncreaseThrottle(0.1f);
                if (Throttle >= (AtTarget / 100))
                {
                    ThrottleInput = 0;
                    targetChanged = false;
                }
            }
            else if (targetChanged && Throttle >= (AtTarget / 100))
            {
                atReduceThrottle(0.1f);
                if (Throttle <= (AtTarget / 100))
                {
                    ThrottleInput = 0;
                    targetChanged = false;
                }
            }
        }
        //Called by both:
        private void atReduceThrottle(float AdjustmentFactor)
        {
            ThrottleInput = -AdjustmentFactor;
            ThrottleInput = Mathf.Clamp(ThrottleInput, -1, 1);
        }
        private void atIncreaseThrottle(float AdjustmentFactor)
        {
            ThrottleInput = AdjustmentFactor;
            ThrottleInput = Mathf.Clamp(ThrottleInput, -1, 1);
        }
        #endregion
        #endregion        
        #region [Auto Pilot]
        private void initAP()
        {
            ApOnline = true;
            ApInCommand = false;          

            ApAltitudeTarget = 0;
            ApVsTarget = 0;
            ApHeadingTarget = 0;

            ApPitchDir = 1;
            ApMaxVerticalRate = 10;
        }
        private void runAP()
        {
            if (ApToggleInput) { ToggleAutoPilot(); }
            if (ApOverrideInputPitch) { ApModeAltitude = false; }
            if (ApOverrideInputYawRoll) { ApModeHeading = false; }
            if (!ApModeAltitude && !ApModeHeading) { ApInCommand = false; }
            if (!ApOnline) { ApInCommand = false; }

            apControlFlightLevel();
            apControlFlightHeading();
        }

        #region AP Altitude & Heading
        public void ToggleModeAltitude()
        {
            if (ApOnline) { ApModeAltitude = !ApModeAltitude; }
        }
        public void ToggleModeHeading()
        {
            if (ApOnline) { ApModeHeading = !ApModeHeading; }
        }
        public void ToggleAutoPilot()
        {
            if (ApOnline)
            {
                ApInCommand = !ApInCommand;
                if(!ApInCommand)
                {
                    ApModeHeading = false;
                    ApModeAltitude = false;
                }
            }
            else
            {
                ApOnline = !ApOnline;
            }
        }

        public void SetAutoPilotAltitudeTarget(float target)
        {
            ApAltitudeTarget = Mathf.Clamp(target, 0, m_maxServiceCeiling);
        }
        public void SetAutoPilotVerticalSpeedTarget(float target)
        {
            ApVsTarget = target;                   
        }
        public void SetAutoPilotHeadingTarget(float target)
        {
            ApHeadingTarget = Mathf.Clamp(target, 0, 360);
            ApHeadingAltitude = Altitude;
        }

        private void apControlFlightLevel()
        {
            if (ApInCommand && ApModeAltitude) // if this mode is active
            {                
                if (Altitude < ApAltitudeTarget) { ApPitchDir = 1; } //Set flight dir based on the altitude and target altitude.
                else { ApPitchDir = -1; }                
                Vector3 targetVerticalVelocity = (m_Rigidbody.velocity - (Vector3.up * ApVsTarget * ApPitchDir)) * Time.deltaTime;
                float pitchAngleTarget = targetVerticalVelocity.y * ApVsTarget;

                PitchInput = pitchAngleTarget;
            }                                          
        }      
        private void apControlFlightHeading()
        {
            if (ApInCommand && ApModeHeading)
            {
                ApMaxRollAngle = 0.75f;                                
                if (Heading + 360 - ApHeadingTarget > 180) { ApHeadingDir = 1; }
                else { ApHeadingDir = -1; }
                Vector3 oldAngularVelocity = m_Rigidbody.angularVelocity;
                float rollRate = (m_Rigidbody.angularVelocity - oldAngularVelocity).x / Time.deltaTime;
                RollInput = Mathf.InverseLerp(ApMaxRollAngle, 0, Mathf.Abs(RollAngle)) * ApHeadingDir;
                //RollInput = Mathf.InverseLerp(ApMaxRollAngle, 0, Mathf.Abs(RollAngle)) * ApHeadingDir;
                Mathf.Clamp(-1, 1, RollInput);
            }
        }
        private void apLevelOutPitch()
        {           
            PitchInput = -PitchAngle;
        }
        private void apLevelOutRoll()
        {
            RollInput = -RollAngle;
        }

        #endregion
        #endregion
        #endregion
        //-------------------------------------------------------------------------------------------------------//
        //  ENVIRONTMENT CONDITIONS FUNCTIONS                                                                    //
        //-------------------------------------------------------------------------------------------------------//
        #region [ENVIRONMENT] Main Functions
        private void controlWeatherImpactTypes()
        {
            AffectedByWeather = m_aircraftAffectedByEnvironment;
            if (!AffectedByWeather)
            {
                AffectedByAtmosphere = false;
                AffectedByPrecipitation = false;
                AffectedByWind = false;
            }
            else
            {
                if (GameObject.FindGameObjectWithTag("weatherController") != null)
                {
                    AffectedByAtmosphere = m_aircraftAffectedByAthmosphere;
                    AffectedByPrecipitation = m_aircraftAffectedByPrecipitation;
                    AffectedByWind = m_aircraftAffectedByWind;
                }
                else
                {
                    AffectedByWeather = false;
                    AffectedByAtmosphere = false;
                    AffectedByPrecipitation = false;
                    AffectedByWind = false;
                }

            }
        }             
        private void controlAircraftWeatherModifiers()
        {
            if (AffectedByAtmosphere)
            {
                calculateAtmosphereAtAltitude();
                calculateEfficiencies();
            }
            else
            {
                EngineEfficiency = 1;
                ControlSurfaceEfficiency = 1;
                DragEfficiency = 1;
            }
            if (AffectedByWind)
            {
                calculateWindAtAltitude();
                calculateWindFluctuations();                
            }
            else
            {
                WindStrength = 0;
            }
            if (AffectedByPrecipitation)
            {

            }
        }
        #endregion       
        #region [ENVIRONMENT] Atmospheric Values At Altitude
        private void calculateAtmosphereAtAltitude()
        {
            calculateAltitudeTemperature();
            calculateAltitudeHumidity();
            calculateAltitudeAirdensity();
        }
        private void calculateAltitudeTemperature()
        {
            //Air Temperature drops by 1°C for every 100m of altitude in a linear fashion in 'good' weather conditions. 
            //Air Temperature drops by 0.6°C for every 100m of altitude when rainfall/snowfall occurs.
            AltitudeTemperature = CurrentSeaLevelTemperature - (TemperatureFalloffRate * Altitude / 100);
        }
        private void calculateAltitudeHumidity()
        {
            //Relative Humidity drops approximately by 0.25% every 100m of altitude.
            AltitudeHumidity = CurrentSeaLevelHumidity - (HumidityFalloffRate * Altitude / 100);
        }
        private void calculateAltitudeAirdensity()
        {
            //We calculate the air density based on the sea level airpressure, altitude humidity and altitude temperature.
            //For reference, sea level air density at 15°C and 1013hPa is around 1225 kg/m3.
            //287 is the gas constant of dry air.
            //Alt. Temperature + 287 is the °C to Kelvin convserion.
            //0.003f is a correction factor.
            //Altitude Humidity/100 so that it's a decimal.
            AltitudeAirdensity = CurrentSeaLevelAirpressure / (287 * (AltitudeTemperature + 273.15f) * (1 - (0.003f * AltitudeHumidity / 100)));
        }
        private void calculateSeaLevelDensity()
        {
            CurrentSeaLevelAirDensity = CurrentSeaLevelAirpressure / (287 * (CurrentSeaLevelTemperature + 273.15f) * (1 - (0.003f * CurrentSeaLevelHumidity / 100)));
        }
        #endregion        
        #region [ENVIRONMENT] Atmospheric Effect On Aircraft At Altitude

        void calculateEfficiencies()
        {
            float minDensity = 0.00909935413f;
            float maxDensity = 0.01620037228f;
            float altitudeEfficiencyValue = Mathf.InverseLerp(m_maxServiceCeiling, 0, Altitude);
            float temperatureEfficiencyValue = m_thrustTemperatureRatio.Evaluate(Mathf.InverseLerp(-40, 60, AltitudeTemperature));
            float densityEfficiencyValue = m_thrustDensityRatio.Evaluate(Mathf.InverseLerp(minDensity, maxDensity, AltitudeAirdensity));
            EngineEfficiency = (altitudeEfficiencyValue + temperatureEfficiencyValue + densityEfficiencyValue) / 3;
            ControlSurfaceEfficiency = (altitudeEfficiencyValue + temperatureEfficiencyValue + densityEfficiencyValue) / 3;
            DragEfficiency = altitudeEfficiencyValue;
        }

        #endregion              
        #region [ENVIRONMENT] Wind Effect At Altitude
        private void calculateWindAtAltitude()
        {
            AltitudeWindFactor = 1 + Mathf.InverseLerp(0, m_maxServiceCeiling, Altitude);
        }
        private void calculateWindFluctuations()
        {
            WindStrength = m_windZone.ZoneWindStrength;
            WindStrength += m_windZone.ZoneWindStrength * AltitudeWindFactor;
        }
        #endregion
        //-------------------------------------------------------------------------------------------------------//
        //  DEBUG & INIT FUNCTIONS                                                                              //
        //-------------------------------------------------------------------------------------------------------//
        #region [OTHER] Main Init Functions
        private void getAircraftComponents()
        {
            m_Rigidbody = GetComponent<Rigidbody>();
            if (customCoM) { m_Rigidbody.centerOfMass = customCoM.localPosition; }
        }
        private void setUpAircraft()
        {
            m_Immobilized = false;                                   
            if (m_useAircraftStartSettings)
            {
                if (m_startInMidAir) { m_Rigidbody.velocity = m_startVelocity; }
                if (m_startAtCustomPosition && m_startPosition != null) { gameObject.transform.position = m_startPosition.transform.position; }
                if (m_hasEngines) { setEngineState(m_EngineOn); }
                if (m_usesfuel) { initFuel(); }
                if (m_usesfuel && m_startWithCustomFuelAmount) { addFuel(m_FuelStartAmount); }
                if (m_haslandingGearRetractable) { setLandingGear(m_landingGearAtStart); }
            }
            else
            {
                if (m_hasEngines) { setEngineState(false); }
                if (m_usesfuel) { initFuel(); }
                if (m_haslandingGearRetractable) { setLandingGear(true); }
            }
            CountLandingGearWheels();
            TogaPowerOutput = m_MaxEnginePower * (1f + (m_TogaModePowerOverride / 100));
            ActiveAutomatics = m_hasAutoStability;
        }
        private void initStartingValues()
        {
            m_OriginalDrag = m_Rigidbody.drag;
            m_OriginalAngularDrag = m_Rigidbody.angularDrag;
            m_originalLandingGearDrag = m_LandingGearDrag;
            m_originalMaxPower = MaxEnginePower;
            m_originalPosition = gameObject.transform;
            //m_originalRotation = Quaternion.identity;

            AircraftStateFlying = false;
            AircraftStateStalled = false;
            AircraftStateLanding = false;
            AircraftStateGrounded = false;
            AircraftStateStationary = false;
            AircraftStateParked = false;
            AircraftStateTakingOff = false;
            AircraftStateCrashed = false;
        }           

        public void Immobilize(bool immobalized) //Immobilize can be called from other objects, for example if this plane is hit by a weapon and should become uncontrollable
        {
            m_Immobilized = immobalized;
        }
        #endregion

        #region [DEBUG] Debug Functions
        public void resetPosition()
        {
            gameObject.transform.position = m_originalPosition.position;
        }
        public void resetRotation()
        {
            gameObject.transform.rotation = m_originalPosition.rotation;
        }
        public void freezePosition()
        {
            m_Rigidbody.constraints = RigidbodyConstraints.FreezePosition;
            m_Rigidbody.constraints = RigidbodyConstraints.FreezeRotation;
        }
        public void freezeRotation()
        {
            m_Rigidbody.constraints = RigidbodyConstraints.FreezeRotation;
        }
        public void unfreeze()
        {
            m_Rigidbody.constraints = RigidbodyConstraints.None;
        }
        public void forceForward()
        {
            m_Rigidbody.AddForce(0, 0, 300000);
        }
        public void killForce()
        {
            m_Rigidbody.velocity = new Vector3(0, 0, 0);
        }
        public void addAltitude()
        {
            Vector3 altiadd = new Vector3(0, 10, 0);
            gameObject.transform.position += altiadd; 
        }
        public void reduceAltitude()
        {
            Vector3 altired = new Vector3(0, -10, 0);
            gameObject.transform.position += altired;
        }
        #endregion
    }
}


// Custom Editor
#if UNITY_EDITOR
namespace Viguar.Aircraft
{
    [CustomEditor(typeof(aircraftController)), InitializeOnLoadAttribute]
    public class aircraftControllerEditor : Editor
    {
        aircraftController sts;
        SerializedObject SerSTS;

        private void OnEnable()
        {
            sts = (aircraftController)target;
            SerSTS = new SerializedObject(sts);
        }
        public override void OnInspectorGUI()
        {
            SerSTS.Update();

            #region Aircraft Set-Up
            #region Script Main Header
            EditorGUILayout.Space();
            GUILayout.Label("Viguar Aircraft Controller", new GUIStyle(GUI.skin.label) { alignment = TextAnchor.MiddleCenter, fontStyle = FontStyle.Bold, fontSize = 12 });
            //GUILayout.Label("3", new GUIStyle(GUI.skin.label) { alignment = TextAnchor.MiddleCenter, fontStyle = FontStyle.Normal, fontSize = 11 });
            EditorGUILayout.Space();
            #endregion
            EditorGUILayout.LabelField("", GUI.skin.horizontalSlider); //Header Divider Bar
            GUILayout.Label("Controller Configuration", new GUIStyle(GUI.skin.label) { alignment = TextAnchor.MiddleLeft, fontStyle = FontStyle.Bold, fontSize = 12 }, GUILayout.ExpandWidth(true)); //Section Title
            EditorGUILayout.Space();

            //PhysicsSetup
            GUILayout.Label("Physics Set-Up", new GUIStyle(GUI.skin.label) { alignment = TextAnchor.MiddleLeft, fontStyle = FontStyle.Bold, fontSize = 11 }, GUILayout.ExpandWidth(true)); //Section SubTitle 
            sts.customCoM = EditorGUILayout.ObjectField(new GUIContent("Custom Center of Mass", "Override the rigidbodies calculated CoM."), sts.customCoM, typeof(Transform), true) as Transform;
            EditorGUILayout.Space();

            //AircraftSetup
            GUILayout.Label("Aircraft Set-Up", new GUIStyle(GUI.skin.label) { alignment = TextAnchor.MiddleLeft, fontStyle = FontStyle.Bold, fontSize = 11 }, GUILayout.ExpandWidth(true)); //Section SubTitle             
            sts.m_hasFlaps = EditorGUILayout.ToggleLeft(new GUIContent("Aircraft Has Flaps", "Toggle if the aircraft has flaps."), sts.m_hasFlaps);
            sts.m_hasEngines = EditorGUILayout.ToggleLeft(new GUIContent("Aircraft Has Engines", "If and how many engines the aircraft has."), sts.m_hasEngines);
            if (sts.m_hasEngines) //Only displays engine options if it has engines
            {
                EditorGUI.indentLevel++;
                sts.m_usesfuel = EditorGUILayout.ToggleLeft(new GUIContent("Engine Uses Fuel", "The the engines will use and run out of fuel"), sts.m_usesfuel);
                EditorGUI.indentLevel--;
            }
            sts.m_haslandingGearRetractable = EditorGUILayout.ToggleLeft(new GUIContent("Aircraft Has Retractable Landing Gear", "Only toggle if the aircraft has a retractable landing gear."), sts.m_haslandingGearRetractable);
            sts.m_hasAutoStability = EditorGUILayout.ToggleLeft(new GUIContent("Automatically Stabilise", "Aircraft will stabilise automatically"), sts.m_hasAutoStability);
            EditorGUILayout.Space();

            //EnvironmentSetup
            GUILayout.Label("Environment Set-Up", new GUIStyle(GUI.skin.label) { alignment = TextAnchor.MiddleLeft, fontStyle = FontStyle.Bold, fontSize = 11 }, GUILayout.ExpandWidth(true)); //Section SubTitle 
            sts.m_aircraftAffectedByEnvironment = EditorGUILayout.ToggleLeft(new GUIContent("Environment Affects Aircraft", "Toggle for the environment affecting aircraft performance."), sts.m_aircraftAffectedByEnvironment);
            if (sts.m_aircraftAffectedByEnvironment)
            {
                EditorGUI.indentLevel++;
                sts.m_aircraftAffectedByAthmosphere = EditorGUILayout.ToggleLeft(new GUIContent("Athmosphere Affects Aircraft", "Toggle for the athmosphere affecting aircraft performance."), sts.m_aircraftAffectedByAthmosphere);
                sts.m_aircraftAffectedByWind = EditorGUILayout.ToggleLeft(new GUIContent("Wind Affects Aircraft", "Toggle for wind affecting aircraft performance."), sts.m_aircraftAffectedByWind);
                sts.m_aircraftAffectedByPrecipitation = EditorGUILayout.ToggleLeft(new GUIContent("Precipitation Affects Aircraft", "Toggle for the precipitation affecting aircraft performance."), sts.m_aircraftAffectedByPrecipitation);
                EditorGUI.indentLevel--;
            }
            EditorGUILayout.Space();

            //Custom Settings
            GUILayout.Label("Custom Set-Up", new GUIStyle(GUI.skin.label) { alignment = TextAnchor.MiddleLeft, fontStyle = FontStyle.Bold, fontSize = 11 }, GUILayout.ExpandWidth(true)); //Section SubTitle 
            sts.m_useAircraftStartSettings = EditorGUILayout.ToggleLeft(new GUIContent("Aircraft Custom Start Settings", "Configuration of custom start values, e.g. position, start in mid air, ..."), sts.m_useAircraftStartSettings);
            EditorGUILayout.Space();
            #endregion

            #region Aerodynamic Behavior & Flight States
            EditorGUILayout.LabelField("", GUI.skin.horizontalSlider); //Header Divider Bar
            GUILayout.Label("Aerodynamic Behavior & Flight States", new GUIStyle(GUI.skin.label) { alignment = TextAnchor.MiddleLeft, fontStyle = FontStyle.Bold, fontSize = 12 }, GUILayout.ExpandWidth(true)); //Section Title
            EditorGUILayout.Space();

            #region Aircraft Aerodynamic Properties
            GUILayout.Label("Aircraft Aerodynamic Properties", new GUIStyle(GUI.skin.label) { alignment = TextAnchor.MiddleLeft, fontStyle = FontStyle.Bold, fontSize = 11 }, GUILayout.ExpandWidth(true)); //Section SubTitle            
            sts.m_maxServiceCeiling = EditorGUILayout.IntSlider(new GUIContent("Maximum Altitude", "The maximum height the aircraft can go."), sts.m_maxServiceCeiling, 100, 100000);
            sts.m_Lift = EditorGUILayout.Slider(new GUIContent("Aircraft Lift", "The amount of lift the vehicle generates when moving forwards."), sts.m_Lift, 0.002f, 20f);
            sts.m_ZeroLiftSpeed = EditorGUILayout.Slider(new GUIContent("Max. Lift Speed", "The maximum speed at which the vehicle will generate lift."), sts.m_ZeroLiftSpeed, 0f, 300f);
            sts.m_AerodynamicEffect = EditorGUILayout.Slider(new GUIContent("Aerodynamic Effect", "The amount by which the aircraft be turning towards its moving direction."), sts.m_AerodynamicEffect, 0.02f, 5f);
            sts.m_DragIncreaseFactor = EditorGUILayout.Slider(new GUIContent("Drag Increase", "The increase of drag relative to the aircrafts speed."), sts.m_DragIncreaseFactor, 0f, 0.1f);            
            EditorGUILayout.Space();
            #endregion

            #region Aircraft Flight States Settings
            GUILayout.Label("Aircraft Flight State Parameters", new GUIStyle(GUI.skin.label) { alignment = TextAnchor.MiddleLeft, fontStyle = FontStyle.Bold, fontSize = 11 }, GUILayout.ExpandWidth(true)); //Section SubTitle         
            sts.m_stallMargin = EditorGUILayout.Slider(new GUIContent("Stall Sensitivity", "The sensitivity of reckognising an aircraft stall. 0 = Little Sensitive, 1 = Very Sensitive"), sts.m_stallMargin, 0.001f, 1f);
            sts.m_MaxSafeLandingSpeed = EditorGUILayout.Slider(new GUIContent("Max. Landing Speed", "The maximum speed for landing conditions to return true."), sts.m_MaxSafeLandingSpeed, 1f, 500f);
            sts.m_MaxSafeLandingVerticalSpeed = EditorGUILayout.Slider(new GUIContent("Max. Vertical Landing Speed", "The maximum vertical speed for landing conditions to return true."), sts.m_MaxSafeLandingVerticalSpeed, 1f, 500f);
            sts.m_LandingAltitudeMargin = EditorGUILayout.Slider(new GUIContent("Landing Detection Altitude", "The maximum altitude for landing conditions to return true"), sts.m_LandingAltitudeMargin, 1f, 150f);
            sts.m_MinTakeoffSpeed = EditorGUILayout.Slider(new GUIContent("Minimum Takeoff Speed", "The minimum speed at which the aircraft can be considered to be taking off while grounded."), sts.m_MinTakeoffSpeed, 1f, 300f);
            sts.takeOffForce = EditorGUILayout.Slider(new GUIContent("Take Off Force", "The force that helps the aircraft rotate when taking off"), sts.takeOffForce, 0f, 50f);
            EditorGUILayout.Space();
            #endregion
            #endregion

            #region Aircraft Flight Control Characteristics
            EditorGUILayout.LabelField("", GUI.skin.horizontalSlider); //Header Divider Bar
            GUILayout.Label("Aircraft Flight Control Characteristics", new GUIStyle(GUI.skin.label) { alignment = TextAnchor.MiddleLeft, fontStyle = FontStyle.Bold, fontSize = 12 }, GUILayout.ExpandWidth(true)); //Section Title
            EditorGUILayout.Space();

            #region Aircraft Control Properties
            GUILayout.Label("Aircraft Control Properties", new GUIStyle(GUI.skin.label) { alignment = TextAnchor.MiddleLeft, fontStyle = FontStyle.Bold, fontSize = 11 }, GUILayout.ExpandWidth(true)); //Section SubTitle         
            sts.m_RollEffect = EditorGUILayout.Slider(new GUIContent("Aircraft Roll Response", "The amount by which the aircraft will roll on input."), sts.m_RollEffect, 0.1f, 5000f);
            sts.m_PitchEffect = EditorGUILayout.Slider(new GUIContent("Aircraft Pitch Response", "The amount by which the aircraft will pitch on input."), sts.m_PitchEffect, 0.1f, 5000f);
            sts.m_YawEffect = EditorGUILayout.Slider(new GUIContent("Aircraft Yaw Response", "The amount by which the aircraft will yaw on input."), sts.m_YawEffect, 0.1f, 5000f);
            sts.m_BankedTurnEffect = EditorGUILayout.Slider(new GUIContent("Aircraft Banking Turn Response", "The amount by which the aircraft will turn when in a roll."), sts.m_BankedTurnEffect, 0.1f, 5000f);
            if (sts.m_aircraftAffectedByAthmosphere)
            {
                sts.m_thrustTemperatureRatio = EditorGUILayout.CurveField(new GUIContent("Temperature Efficiency Ratio", "The reduction of control efficiency over temperate increase."), sts.m_thrustTemperatureRatio);
                sts.m_thrustDensityRatio = EditorGUILayout.CurveField(new GUIContent("Air Density Efficiency Ratio", "The increase of control efficiency over reduction of air density."), sts.m_thrustDensityRatio);
            }
            if (sts.m_hasEngines) //Only displays engine options if it has engines
            {
                sts.m_ThrottleChangeSpeed = EditorGUILayout.Slider(new GUIContent("Aircraft Throttle Response", "The rate of change of desired throttle amount."), sts.m_ThrottleChangeSpeed, 1f, 5f);
            }
            sts.m_WheelBrakesEffect = EditorGUILayout.Slider(new GUIContent("Aircraft Wheel Brake Strentgh", "The strength of the aircrafts wheel brakes."), sts.m_WheelBrakesEffect, 0.001f, 1000f);
            sts.m_AirBrakesEffect = EditorGUILayout.Slider(new GUIContent("Aircraft Air Brake Drag", "The amount of drag that the air brake generates."), sts.m_AirBrakesEffect, 1f, 10f);
            if (sts.m_haslandingGearRetractable) //Only displays langding gear options if it has retractable landing gear
            {
                sts.m_LandingGearDrag = EditorGUILayout.Slider(new GUIContent("Aircraft Landing Gear Drag", "The amount of drag that the landing gear generates."), sts.m_LandingGearDrag, 1f, 10f);
                sts.m_MaxSteeringWheelAngle = EditorGUILayout.IntSlider(new GUIContent("Steering Wheel Turn Max.", "The maximum turn that the nose gear steering can do."), sts.m_MaxSteeringWheelAngle, 1, 60);
                sts.SteeringWheelContainer = EditorGUILayout.ObjectField(new GUIContent("Steering Wheel Container", "The parent GameObject containing Objects with Wheelcolliders."), sts.SteeringWheelContainer, typeof(GameObject), true) as GameObject;
            }
            EditorGUILayout.Space();
            #endregion

            #region Flaps Properties
            if (sts.m_hasFlaps)
            {
                GUILayout.Label("Aircraft Flaps Properties", new GUIStyle(GUI.skin.label) { alignment = TextAnchor.MiddleLeft, fontStyle = FontStyle.Bold, fontSize = 11 }, GUILayout.ExpandWidth(true)); //Section Title
                sts.m_flapStepDegrees = EditorGUILayout.IntSlider(new GUIContent("Flap Step Degrees", "The amount of thrust that the engine generates."), sts.m_flapStepDegrees, 1, 30);
                sts.m_maxFlapDegrees = EditorGUILayout.IntSlider(new GUIContent("Flap Step Degrees", "The amount of thrust that the engine generates."), sts.m_maxFlapDegrees, 30, 90);
                sts.m_flapEffect = EditorGUILayout.Slider(new GUIContent("Flap Strength", "The strentgh of the flaps."), sts.m_flapEffect, 1f, 100f);
                sts.m_flapEfficiency = EditorGUILayout.CurveField(new GUIContent("Flap Efficiency", "The efficiency of Flap Strength over speed."), sts.m_flapEfficiency);
                sts.m_flapDragEfficiency = EditorGUILayout.CurveField(new GUIContent("Flap Drag Over Speed", "The drag increase of flaps over speed."), sts.m_flapDragEfficiency);
                EditorGUILayout.Space();
            }
            #endregion

            #region Aircraft Engine Properties            
            if (sts.m_hasEngines) //Only displays engine options if it has engines
            {
                GUILayout.Label("Aircraft Engine Properties", new GUIStyle(GUI.skin.label) { alignment = TextAnchor.MiddleLeft, fontStyle = FontStyle.Bold, fontSize = 11 }, GUILayout.ExpandWidth(true)); //Section SubTitle
                sts.m_MaxEnginePower = EditorGUILayout.Slider(new GUIContent("Max. Engine Thrust", "The amount of thrust that the engine generates."), sts.m_MaxEnginePower, 1f, 100000f);
                sts.m_spoolRate = EditorGUILayout.CurveField(new GUIContent("Engine Spoolup Speed", "The speed of engine spool to the set throttle input."), sts.m_spoolRate);
                sts.m_TogaModePowerOverride = EditorGUILayout.IntSlider(new GUIContent("Toga Mode Power Override", "The override of max engine power in percent."), sts.m_TogaModePowerOverride, 1, 100);
                if (sts.m_usesfuel)
                {
                    EditorGUILayout.Space();
                    sts.m_fuelTankSize = EditorGUILayout.Slider(new GUIContent("Fuel Tank Size", "The amount of fuel that the aircraft can hold."), sts.m_fuelTankSize, 1f, 1000f);
                    sts.m_fuelconsumption = EditorGUILayout.CurveField(new GUIContent("Fuel Burn Rate", "The speed at which the plane burns fuel."), sts.m_fuelconsumption);                 
                }
                EditorGUILayout.Space();
            }
            #endregion

            #region Aircraft Flight Automatics Properties
            if (sts.m_hasAutoStability) //Only displays auto options if it is toggled
            {
                GUILayout.Label("Aircraft Automatics", new GUIStyle(GUI.skin.label) { alignment = TextAnchor.MiddleLeft, fontStyle = FontStyle.Bold, fontSize = 11 }, GUILayout.ExpandWidth(true)); //Section SubTitle
                sts.m_AutoPitchLevel = EditorGUILayout.Slider(new GUIContent("Auto Pitch", "The amount by which the aircraft will automatically pitch towards a desired target-pitch."), sts.m_AutoPitchLevel, 0f, 30f);
                sts.m_AutoRollLevel = EditorGUILayout.Slider(new GUIContent("Auto Roll", "The amount by which the aircraft will automatically roll towards a desired target-roll."), sts.m_AutoRollLevel, 0f, 30f);
                sts.m_AutoTurnPitch = EditorGUILayout.Slider(new GUIContent("Auto Turn", "The amount by which the aircraft will automatically pitch when in a roll to achieve a turn."), sts.m_AutoTurnPitch, 0f, 30f);
                sts.m_AutoRudder = EditorGUILayout.Slider(new GUIContent("Auto Rudder", "The amount by which the aircraft will automatically use its rudder towards a desired target-yaw."), sts.m_AutoRudder, 0f, 30f);
                EditorGUILayout.Space();
            }
            #endregion
            #endregion

            #region Start Settings
            if (sts.m_useAircraftStartSettings)
            {
                EditorGUILayout.LabelField("", GUI.skin.horizontalSlider); //Header Divider Bar
                GUILayout.Label("Custom Set-Up", new GUIStyle(GUI.skin.label) { alignment = TextAnchor.MiddleLeft, fontStyle = FontStyle.Bold, fontSize = 12 }, GUILayout.ExpandWidth(true)); //Section Title
                EditorGUILayout.Space();

                #region Starting Position & Velocity
                GUILayout.Label("Starting Position & Velocity", new GUIStyle(GUI.skin.label) { alignment = TextAnchor.MiddleLeft, fontStyle = FontStyle.Bold, fontSize = 11 }, GUILayout.ExpandWidth(true));
                sts.m_startInMidAir = EditorGUILayout.ToggleLeft(new GUIContent("Starts in Mid Air", "Configuration options for a mid-air start"), sts.m_startInMidAir);
                if (sts.m_startInMidAir)
                {
                    EditorGUI.indentLevel++;
                    sts.m_startVelocity = EditorGUILayout.Vector3Field(new GUIContent("Mid Air Start Velocity", "Configuration of the mid-air starting velocity"), sts.m_startVelocity);
                    EditorGUI.indentLevel--;
                }
                sts.m_startAtCustomPosition = EditorGUILayout.ToggleLeft(new GUIContent("Start at Custom Position", "Configuration of a custom mid-air start position"), sts.m_startAtCustomPosition);
                if (sts.m_startAtCustomPosition)
                {
                    EditorGUI.indentLevel++;
                    sts.m_startPosition = EditorGUILayout.ObjectField(new GUIContent("Start Position", "Places the aircraft to the defined transform at runtime. "), sts.m_startPosition, typeof(Transform), true) as Transform;
                    EditorGUI.indentLevel--;
                }
                EditorGUILayout.Space();
                #endregion
                #region Starting Engine & Fuel
                if (sts.m_hasEngines)
                {
                    GUILayout.Label("Starting Engine & Fuel State", new GUIStyle(GUI.skin.label) { alignment = TextAnchor.MiddleLeft, fontStyle = FontStyle.Bold, fontSize = 11 }, GUILayout.ExpandWidth(true));
                    sts.m_EngineOn = EditorGUILayout.ToggleLeft(new GUIContent("Engine On At Start", "Toggle if the landing gear should be extended at start."), sts.m_EngineOn);
                    if (sts.m_usesfuel)
                    {
                        EditorGUI.indentLevel++;
                        sts.m_startWithCustomFuelAmount = EditorGUILayout.ToggleLeft(new GUIContent("Custom Fuel Amount At Start", "Define a custom amount of fuel remaining when the scene starts."), sts.m_startWithCustomFuelAmount);
                        if (sts.m_startWithCustomFuelAmount)
                        {
                            EditorGUI.indentLevel++;
                            sts.m_FuelStartAmount = EditorGUILayout.Slider(new GUIContent("Fuel Start Amount", "The amount of fuel remaining when the scene starts."), sts.m_FuelStartAmount, 1f, 1000f);
                            EditorGUI.indentLevel--;
                        }
                        EditorGUI.indentLevel--;
                    }
                }
            }
            EditorGUILayout.Space();
            #endregion
            #region Starting Flight Systems
            if (sts.m_haslandingGearRetractable)
            {
                sts.m_landingGearAtStart = EditorGUILayout.ToggleLeft(new GUIContent("Gear Extended At Start", "Toggle if the landing gear should be extended at start."), sts.m_landingGearAtStart);
            }

            #endregion

            #endregion

            //Sets any changes from the prefab
            if (GUI.changed)
            {
                EditorUtility.SetDirty(sts);
                Undo.RecordObject(sts, "FPC Change");
                SerSTS.ApplyModifiedProperties();
            }
        }

    }
}
#endif